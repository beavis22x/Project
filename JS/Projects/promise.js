'use strict';

// Коллбэки плохи в алгоритмах где 10 - 15
// операций должны происходить друг за дургом
// и попадают в колбэк хэлл
//ПОэтому используется Promise

console.log('Запрос данных...');

const req = new Promise(function(resolve, reject){
    setTimeout(() => {
        console.log('Подготовка данных...');
        
        const product = {
            name: 'TV',
            price: 2000
        };
    
        resolve(product);
    }, 2000);
});

// req.then((product) => {
//     const req2 = new Promise((resolve, reject) => {  Можно не создавать вторую переменную
//         setTimeout(() => {                           промис. См ниже.
//             product.status = 'ordered';
//             resolve(product);
//          }, 2000);
//     });

//     req2.then(data => {
//         console.log(data);
//     });
// });

// Можно у then  возвращать реторном

req.then((product) => {
    return new Promise((resolve, reject) => { 
        setTimeout(() => {                           
            product.status = 'ordered';
            resolve(product); // здесь для теста reject();
         }, 2000);
    }).then(data => {
        data.modify = true;
        return data;
    }).then((data) => {
       console.log(data);
    }).catch(() => {
        console.error('Произошла ошибака');
    }).finally(() => {
        console.log('Finally');
    });
});
// Подается запрос к серверу если все идет хорошо 
// гуляем по ветки резолв, если где-то происходит ошибка,
// она обрабатывается блоком кэтч в ней например можно вывести
//для пользователя сообщение об ошибке,
// файнали будет всегда отрабатывать туда можно поместить,
// код который будеточищать поля для ввода, закрывать 
// модальное окно. 

const test = time => {
    return new Promise(resolve => {
        setTimeout(() => resolve(), time);
    });
};

// test(1000).then(() => console.log('1000 ms'));
// test(2000).then(() => console.log('2000 ms'));
// Функционал для запуска одинковых операций 
// через определенный промежуток времени

Promise.all([test(1000),test(2000)]).then(() => {
    console.log('All');
});
// промис олл служит чтобы точно убедились в том
// что все промисы уже выполнились
// Например несколько запросов на разные сервера
// для того чтоб получить 4 разных изображения
// а сервера отвечают с разным промежутком времени
// Но мы хотим чтобы на сайте появились 4 изображения 
// когда она все сразу загрузяться (т.е. мы ждем пока
// все промисы загрузятсья и потом что-то делать)

Promise.race([test(1000),test(2000)]).then(() => {
    console.log('FirstofAll');
});
// race переводится как гонка. Метода олл
// ждал пока все выполнятся и потом что-то делал
// а метод рейс начинает что-то делать когда
// подгружается первый
